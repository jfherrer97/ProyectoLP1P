Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    BREAK
    COMILLA
    COMMENT
    DO
    ELSEIF
    EQUALNUMBER
    NOTEQUALV
    PRODUCTO
    RETURN

Grammar

Rule 0     S' -> program
Rule 1     program -> block
Rule 2     block -> constDecl varDecl statement statementList
Rule 3     constDecl -> VAR constAssignmentList SEMICOLON
Rule 4     constDecl -> empty
Rule 5     constAssignmentList -> ID EQUALS NUMBER
Rule 6     statement -> ID EQUALS LBRACKET elements RBRACKET
Rule 7     statement -> ID EQUALS LBRACKET RBRACKET
Rule 8     elements -> expression
Rule 9     elements -> expression COMMA elements
Rule 10    constAssignmentList -> constAssignmentList COMMA ID EQUALS NUMBER
Rule 11    varDecl -> VAR identList SEMICOLON
Rule 12    varDecl -> empty
Rule 13    identList -> ID
Rule 14    identList -> identList COMMA ID
Rule 15    statement -> INPUT LPAREN STRING RPAREN
Rule 16    statement -> ID EQUALS INPUT LPAREN STRING RPAREN
Rule 17    statement -> PRINT LPAREN STRING RPAREN
Rule 18    statement -> PRINT LPAREN expression RPAREN
Rule 19    statement -> PRINT LPAREN expression COMMA STRING COMMA expression RPAREN
Rule 20    statement -> ID EQUALS expression
Rule 21    statement -> IF condition LBRACE statement RBRACE statementIF
Rule 22    statement -> WHILE condition LBRACE statement RBRACE
Rule 23    statement -> FOR ID EQUALS NUMBER SEMICOLON condition SEMICOLON ID PLUSPLUS LBRACE statement RBRACE
Rule 24    statement -> FOR ID IN ID LBRACE statement RBRACE
Rule 25    statement -> empty
Rule 26    statementIF -> ELSE LBRACE statement RBRACE
Rule 27    statementIF -> ELSE IF condition LBRACE statement RBRACE
Rule 28    statementIF -> empty
Rule 29    statementList -> statement
Rule 30    statementList -> statementList SEMICOLON statement
Rule 31    condition -> expression relation expression
Rule 32    relation -> EQUALV
Rule 33    relation -> LT
Rule 34    relation -> GT
Rule 35    relation -> LTE
Rule 36    relation -> GTE
Rule 37    expression -> term
Rule 38    factor -> ID DOT ISALPHA LPAREN RPAREN
Rule 39    factor -> ID DOT APPEND LPAREN expression RPAREN
Rule 40    expression -> addingOperator term
Rule 41    expression -> expression addingOperator term
Rule 42    addingOperator -> PLUS
Rule 43    addingOperator -> MINUS
Rule 44    term -> factor
Rule 45    term -> term multiplyingOperator factor
Rule 46    multiplyingOperator -> TIMES
Rule 47    multiplyingOperator -> DIVIDE
Rule 48    factor -> ID
Rule 49    factor -> STRING
Rule 50    factor -> NUMBER
Rule 51    factor -> FALSE
Rule 52    factor -> TRUE
Rule 53    factor -> LPAREN expression RPAREN
Rule 54    empty -> <empty>

Terminals, with rules where they appear

APPEND               : 39
BREAK                : 
COMILLA              : 
COMMA                : 9 10 14 19 19
COMMENT              : 
DIVIDE               : 47
DO                   : 
DOT                  : 38 39
ELSE                 : 26 27
ELSEIF               : 
EQUALNUMBER          : 
EQUALS               : 5 6 7 10 16 20 23
EQUALV               : 32
FALSE                : 51
FOR                  : 23 24
GT                   : 34
GTE                  : 36
ID                   : 5 6 7 10 13 14 16 20 23 23 24 24 38 39 48
IF                   : 21 27
IN                   : 24
INPUT                : 15 16
ISALPHA              : 38
LBRACE               : 21 22 23 24 26 27
LBRACKET             : 6 7
LPAREN               : 15 16 17 18 19 38 39 53
LT                   : 33
LTE                  : 35
MINUS                : 43
NOTEQUALV            : 
NUMBER               : 5 10 23 50
PLUS                 : 42
PLUSPLUS             : 23
PRINT                : 17 18 19
PRODUCTO             : 
RBRACE               : 21 22 23 24 26 27
RBRACKET             : 6 7
RETURN               : 
RPAREN               : 15 16 17 18 19 38 39 53
SEMICOLON            : 3 11 23 23 30
STRING               : 15 16 17 19 49
TIMES                : 46
TRUE                 : 52
VAR                  : 3 11
WHILE                : 22
error                : 

Nonterminals, with rules where they appear

addingOperator       : 40 41
block                : 1
condition            : 21 22 23 27
constAssignmentList  : 3 10
constDecl            : 2
elements             : 6 9
empty                : 4 12 25 28
expression           : 8 9 18 19 19 20 31 31 39 41 53
factor               : 44 45
identList            : 11 14
multiplyingOperator  : 45
program              : 0
relation             : 31
statement            : 2 21 22 23 24 26 27 29 30
statementIF          : 21
statementList        : 2 30
term                 : 37 40 41 45
varDecl              : 2

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . block
    (2) block -> . constDecl varDecl statement statementList
    (3) constDecl -> . VAR constAssignmentList SEMICOLON
    (4) constDecl -> . empty
    (54) empty -> .

  ! shift/reduce conflict for VAR resolved as shift
    VAR             shift and go to state 4
    ID              reduce using rule 54 (empty -> .)
    INPUT           reduce using rule 54 (empty -> .)
    PRINT           reduce using rule 54 (empty -> .)
    IF              reduce using rule 54 (empty -> .)
    WHILE           reduce using rule 54 (empty -> .)
    FOR             reduce using rule 54 (empty -> .)
    SEMICOLON       reduce using rule 54 (empty -> .)
    $end            reduce using rule 54 (empty -> .)

  ! VAR             [ reduce using rule 54 (empty -> .) ]

    program                        shift and go to state 1
    block                          shift and go to state 2
    constDecl                      shift and go to state 3
    empty                          shift and go to state 5

state 1

    (0) S' -> program .



state 2

    (1) program -> block .

    $end            reduce using rule 1 (program -> block .)


state 3

    (2) block -> constDecl . varDecl statement statementList
    (11) varDecl -> . VAR identList SEMICOLON
    (12) varDecl -> . empty
    (54) empty -> .

    VAR             shift and go to state 7
    ID              reduce using rule 54 (empty -> .)
    INPUT           reduce using rule 54 (empty -> .)
    PRINT           reduce using rule 54 (empty -> .)
    IF              reduce using rule 54 (empty -> .)
    WHILE           reduce using rule 54 (empty -> .)
    FOR             reduce using rule 54 (empty -> .)
    SEMICOLON       reduce using rule 54 (empty -> .)
    $end            reduce using rule 54 (empty -> .)

    varDecl                        shift and go to state 6
    empty                          shift and go to state 8

state 4

    (3) constDecl -> VAR . constAssignmentList SEMICOLON
    (5) constAssignmentList -> . ID EQUALS NUMBER
    (10) constAssignmentList -> . constAssignmentList COMMA ID EQUALS NUMBER

    ID              shift and go to state 10

    constAssignmentList            shift and go to state 9

state 5

    (4) constDecl -> empty .

    VAR             reduce using rule 4 (constDecl -> empty .)
    ID              reduce using rule 4 (constDecl -> empty .)
    INPUT           reduce using rule 4 (constDecl -> empty .)
    PRINT           reduce using rule 4 (constDecl -> empty .)
    IF              reduce using rule 4 (constDecl -> empty .)
    WHILE           reduce using rule 4 (constDecl -> empty .)
    FOR             reduce using rule 4 (constDecl -> empty .)
    SEMICOLON       reduce using rule 4 (constDecl -> empty .)
    $end            reduce using rule 4 (constDecl -> empty .)


state 6

    (2) block -> constDecl varDecl . statement statementList
    (6) statement -> . ID EQUALS LBRACKET elements RBRACKET
    (7) statement -> . ID EQUALS LBRACKET RBRACKET
    (15) statement -> . INPUT LPAREN STRING RPAREN
    (16) statement -> . ID EQUALS INPUT LPAREN STRING RPAREN
    (17) statement -> . PRINT LPAREN STRING RPAREN
    (18) statement -> . PRINT LPAREN expression RPAREN
    (19) statement -> . PRINT LPAREN expression COMMA STRING COMMA expression RPAREN
    (20) statement -> . ID EQUALS expression
    (21) statement -> . IF condition LBRACE statement RBRACE statementIF
    (22) statement -> . WHILE condition LBRACE statement RBRACE
    (23) statement -> . FOR ID EQUALS NUMBER SEMICOLON condition SEMICOLON ID PLUSPLUS LBRACE statement RBRACE
    (24) statement -> . FOR ID IN ID LBRACE statement RBRACE
    (25) statement -> . empty
    (54) empty -> .

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
    ID              shift and go to state 12
    INPUT           shift and go to state 13
    PRINT           shift and go to state 14
    IF              shift and go to state 15
    WHILE           shift and go to state 16
    FOR             shift and go to state 17
    SEMICOLON       reduce using rule 54 (empty -> .)
    $end            reduce using rule 54 (empty -> .)

  ! ID              [ reduce using rule 54 (empty -> .) ]
  ! INPUT           [ reduce using rule 54 (empty -> .) ]
  ! PRINT           [ reduce using rule 54 (empty -> .) ]
  ! IF              [ reduce using rule 54 (empty -> .) ]
  ! WHILE           [ reduce using rule 54 (empty -> .) ]
  ! FOR             [ reduce using rule 54 (empty -> .) ]

    statement                      shift and go to state 11
    empty                          shift and go to state 18

state 7

    (11) varDecl -> VAR . identList SEMICOLON
    (13) identList -> . ID
    (14) identList -> . identList COMMA ID

    ID              shift and go to state 20

    identList                      shift and go to state 19

state 8

    (12) varDecl -> empty .

    ID              reduce using rule 12 (varDecl -> empty .)
    INPUT           reduce using rule 12 (varDecl -> empty .)
    PRINT           reduce using rule 12 (varDecl -> empty .)
    IF              reduce using rule 12 (varDecl -> empty .)
    WHILE           reduce using rule 12 (varDecl -> empty .)
    FOR             reduce using rule 12 (varDecl -> empty .)
    SEMICOLON       reduce using rule 12 (varDecl -> empty .)
    $end            reduce using rule 12 (varDecl -> empty .)


state 9

    (3) constDecl -> VAR constAssignmentList . SEMICOLON
    (10) constAssignmentList -> constAssignmentList . COMMA ID EQUALS NUMBER

    SEMICOLON       shift and go to state 21
    COMMA           shift and go to state 22


state 10

    (5) constAssignmentList -> ID . EQUALS NUMBER

    EQUALS          shift and go to state 23


state 11

    (2) block -> constDecl varDecl statement . statementList
    (29) statementList -> . statement
    (30) statementList -> . statementList SEMICOLON statement
    (6) statement -> . ID EQUALS LBRACKET elements RBRACKET
    (7) statement -> . ID EQUALS LBRACKET RBRACKET
    (15) statement -> . INPUT LPAREN STRING RPAREN
    (16) statement -> . ID EQUALS INPUT LPAREN STRING RPAREN
    (17) statement -> . PRINT LPAREN STRING RPAREN
    (18) statement -> . PRINT LPAREN expression RPAREN
    (19) statement -> . PRINT LPAREN expression COMMA STRING COMMA expression RPAREN
    (20) statement -> . ID EQUALS expression
    (21) statement -> . IF condition LBRACE statement RBRACE statementIF
    (22) statement -> . WHILE condition LBRACE statement RBRACE
    (23) statement -> . FOR ID EQUALS NUMBER SEMICOLON condition SEMICOLON ID PLUSPLUS LBRACE statement RBRACE
    (24) statement -> . FOR ID IN ID LBRACE statement RBRACE
    (25) statement -> . empty
    (54) empty -> .

    ID              shift and go to state 12
    INPUT           shift and go to state 13
    PRINT           shift and go to state 14
    IF              shift and go to state 15
    WHILE           shift and go to state 16
    FOR             shift and go to state 17
    SEMICOLON       reduce using rule 54 (empty -> .)
    $end            reduce using rule 54 (empty -> .)

    statement                      shift and go to state 24
    statementList                  shift and go to state 25
    empty                          shift and go to state 18

state 12

    (6) statement -> ID . EQUALS LBRACKET elements RBRACKET
    (7) statement -> ID . EQUALS LBRACKET RBRACKET
    (16) statement -> ID . EQUALS INPUT LPAREN STRING RPAREN
    (20) statement -> ID . EQUALS expression

    EQUALS          shift and go to state 26


state 13

    (15) statement -> INPUT . LPAREN STRING RPAREN

    LPAREN          shift and go to state 27


state 14

    (17) statement -> PRINT . LPAREN STRING RPAREN
    (18) statement -> PRINT . LPAREN expression RPAREN
    (19) statement -> PRINT . LPAREN expression COMMA STRING COMMA expression RPAREN

    LPAREN          shift and go to state 28


state 15

    (21) statement -> IF . condition LBRACE statement RBRACE statementIF
    (31) condition -> . expression relation expression
    (37) expression -> . term
    (40) expression -> . addingOperator term
    (41) expression -> . expression addingOperator term
    (44) term -> . factor
    (45) term -> . term multiplyingOperator factor
    (42) addingOperator -> . PLUS
    (43) addingOperator -> . MINUS
    (38) factor -> . ID DOT ISALPHA LPAREN RPAREN
    (39) factor -> . ID DOT APPEND LPAREN expression RPAREN
    (48) factor -> . ID
    (49) factor -> . STRING
    (50) factor -> . NUMBER
    (51) factor -> . FALSE
    (52) factor -> . TRUE
    (53) factor -> . LPAREN expression RPAREN

    PLUS            shift and go to state 34
    MINUS           shift and go to state 35
    ID              shift and go to state 36
    STRING          shift and go to state 38
    NUMBER          shift and go to state 39
    FALSE           shift and go to state 40
    TRUE            shift and go to state 41
    LPAREN          shift and go to state 37

    condition                      shift and go to state 29
    expression                     shift and go to state 30
    term                           shift and go to state 31
    addingOperator                 shift and go to state 32
    factor                         shift and go to state 33

state 16

    (22) statement -> WHILE . condition LBRACE statement RBRACE
    (31) condition -> . expression relation expression
    (37) expression -> . term
    (40) expression -> . addingOperator term
    (41) expression -> . expression addingOperator term
    (44) term -> . factor
    (45) term -> . term multiplyingOperator factor
    (42) addingOperator -> . PLUS
    (43) addingOperator -> . MINUS
    (38) factor -> . ID DOT ISALPHA LPAREN RPAREN
    (39) factor -> . ID DOT APPEND LPAREN expression RPAREN
    (48) factor -> . ID
    (49) factor -> . STRING
    (50) factor -> . NUMBER
    (51) factor -> . FALSE
    (52) factor -> . TRUE
    (53) factor -> . LPAREN expression RPAREN

    PLUS            shift and go to state 34
    MINUS           shift and go to state 35
    ID              shift and go to state 36
    STRING          shift and go to state 38
    NUMBER          shift and go to state 39
    FALSE           shift and go to state 40
    TRUE            shift and go to state 41
    LPAREN          shift and go to state 37

    condition                      shift and go to state 42
    expression                     shift and go to state 30
    term                           shift and go to state 31
    addingOperator                 shift and go to state 32
    factor                         shift and go to state 33

state 17

    (23) statement -> FOR . ID EQUALS NUMBER SEMICOLON condition SEMICOLON ID PLUSPLUS LBRACE statement RBRACE
    (24) statement -> FOR . ID IN ID LBRACE statement RBRACE

    ID              shift and go to state 43


state 18

    (25) statement -> empty .

    ID              reduce using rule 25 (statement -> empty .)
    INPUT           reduce using rule 25 (statement -> empty .)
    PRINT           reduce using rule 25 (statement -> empty .)
    IF              reduce using rule 25 (statement -> empty .)
    WHILE           reduce using rule 25 (statement -> empty .)
    FOR             reduce using rule 25 (statement -> empty .)
    SEMICOLON       reduce using rule 25 (statement -> empty .)
    $end            reduce using rule 25 (statement -> empty .)
    RBRACE          reduce using rule 25 (statement -> empty .)


state 19

    (11) varDecl -> VAR identList . SEMICOLON
    (14) identList -> identList . COMMA ID

    SEMICOLON       shift and go to state 44
    COMMA           shift and go to state 45


state 20

    (13) identList -> ID .

    SEMICOLON       reduce using rule 13 (identList -> ID .)
    COMMA           reduce using rule 13 (identList -> ID .)


state 21

    (3) constDecl -> VAR constAssignmentList SEMICOLON .

    VAR             reduce using rule 3 (constDecl -> VAR constAssignmentList SEMICOLON .)
    ID              reduce using rule 3 (constDecl -> VAR constAssignmentList SEMICOLON .)
    INPUT           reduce using rule 3 (constDecl -> VAR constAssignmentList SEMICOLON .)
    PRINT           reduce using rule 3 (constDecl -> VAR constAssignmentList SEMICOLON .)
    IF              reduce using rule 3 (constDecl -> VAR constAssignmentList SEMICOLON .)
    WHILE           reduce using rule 3 (constDecl -> VAR constAssignmentList SEMICOLON .)
    FOR             reduce using rule 3 (constDecl -> VAR constAssignmentList SEMICOLON .)
    SEMICOLON       reduce using rule 3 (constDecl -> VAR constAssignmentList SEMICOLON .)
    $end            reduce using rule 3 (constDecl -> VAR constAssignmentList SEMICOLON .)


state 22

    (10) constAssignmentList -> constAssignmentList COMMA . ID EQUALS NUMBER

    ID              shift and go to state 46


state 23

    (5) constAssignmentList -> ID EQUALS . NUMBER

    NUMBER          shift and go to state 47


state 24

    (29) statementList -> statement .

    SEMICOLON       reduce using rule 29 (statementList -> statement .)
    $end            reduce using rule 29 (statementList -> statement .)


state 25

    (2) block -> constDecl varDecl statement statementList .
    (30) statementList -> statementList . SEMICOLON statement

    $end            reduce using rule 2 (block -> constDecl varDecl statement statementList .)
    SEMICOLON       shift and go to state 48


state 26

    (6) statement -> ID EQUALS . LBRACKET elements RBRACKET
    (7) statement -> ID EQUALS . LBRACKET RBRACKET
    (16) statement -> ID EQUALS . INPUT LPAREN STRING RPAREN
    (20) statement -> ID EQUALS . expression
    (37) expression -> . term
    (40) expression -> . addingOperator term
    (41) expression -> . expression addingOperator term
    (44) term -> . factor
    (45) term -> . term multiplyingOperator factor
    (42) addingOperator -> . PLUS
    (43) addingOperator -> . MINUS
    (38) factor -> . ID DOT ISALPHA LPAREN RPAREN
    (39) factor -> . ID DOT APPEND LPAREN expression RPAREN
    (48) factor -> . ID
    (49) factor -> . STRING
    (50) factor -> . NUMBER
    (51) factor -> . FALSE
    (52) factor -> . TRUE
    (53) factor -> . LPAREN expression RPAREN

    LBRACKET        shift and go to state 49
    INPUT           shift and go to state 50
    PLUS            shift and go to state 34
    MINUS           shift and go to state 35
    ID              shift and go to state 36
    STRING          shift and go to state 38
    NUMBER          shift and go to state 39
    FALSE           shift and go to state 40
    TRUE            shift and go to state 41
    LPAREN          shift and go to state 37

    expression                     shift and go to state 51
    term                           shift and go to state 31
    addingOperator                 shift and go to state 32
    factor                         shift and go to state 33

state 27

    (15) statement -> INPUT LPAREN . STRING RPAREN

    STRING          shift and go to state 52


state 28

    (17) statement -> PRINT LPAREN . STRING RPAREN
    (18) statement -> PRINT LPAREN . expression RPAREN
    (19) statement -> PRINT LPAREN . expression COMMA STRING COMMA expression RPAREN
    (37) expression -> . term
    (40) expression -> . addingOperator term
    (41) expression -> . expression addingOperator term
    (44) term -> . factor
    (45) term -> . term multiplyingOperator factor
    (42) addingOperator -> . PLUS
    (43) addingOperator -> . MINUS
    (38) factor -> . ID DOT ISALPHA LPAREN RPAREN
    (39) factor -> . ID DOT APPEND LPAREN expression RPAREN
    (48) factor -> . ID
    (49) factor -> . STRING
    (50) factor -> . NUMBER
    (51) factor -> . FALSE
    (52) factor -> . TRUE
    (53) factor -> . LPAREN expression RPAREN

    STRING          shift and go to state 53
    PLUS            shift and go to state 34
    MINUS           shift and go to state 35
    ID              shift and go to state 36
    NUMBER          shift and go to state 39
    FALSE           shift and go to state 40
    TRUE            shift and go to state 41
    LPAREN          shift and go to state 37

    expression                     shift and go to state 54
    term                           shift and go to state 31
    addingOperator                 shift and go to state 32
    factor                         shift and go to state 33

state 29

    (21) statement -> IF condition . LBRACE statement RBRACE statementIF

    LBRACE          shift and go to state 55


state 30

    (31) condition -> expression . relation expression
    (41) expression -> expression . addingOperator term
    (32) relation -> . EQUALV
    (33) relation -> . LT
    (34) relation -> . GT
    (35) relation -> . LTE
    (36) relation -> . GTE
    (42) addingOperator -> . PLUS
    (43) addingOperator -> . MINUS

    EQUALV          shift and go to state 58
    LT              shift and go to state 59
    GT              shift and go to state 60
    LTE             shift and go to state 61
    GTE             shift and go to state 62
    PLUS            shift and go to state 34
    MINUS           shift and go to state 35

    relation                       shift and go to state 56
    addingOperator                 shift and go to state 57

state 31

    (37) expression -> term .
    (45) term -> term . multiplyingOperator factor
    (46) multiplyingOperator -> . TIMES
    (47) multiplyingOperator -> . DIVIDE

    EQUALV          reduce using rule 37 (expression -> term .)
    LT              reduce using rule 37 (expression -> term .)
    GT              reduce using rule 37 (expression -> term .)
    LTE             reduce using rule 37 (expression -> term .)
    GTE             reduce using rule 37 (expression -> term .)
    PLUS            reduce using rule 37 (expression -> term .)
    MINUS           reduce using rule 37 (expression -> term .)
    ID              reduce using rule 37 (expression -> term .)
    INPUT           reduce using rule 37 (expression -> term .)
    PRINT           reduce using rule 37 (expression -> term .)
    IF              reduce using rule 37 (expression -> term .)
    WHILE           reduce using rule 37 (expression -> term .)
    FOR             reduce using rule 37 (expression -> term .)
    SEMICOLON       reduce using rule 37 (expression -> term .)
    $end            reduce using rule 37 (expression -> term .)
    RBRACE          reduce using rule 37 (expression -> term .)
    RPAREN          reduce using rule 37 (expression -> term .)
    COMMA           reduce using rule 37 (expression -> term .)
    RBRACKET        reduce using rule 37 (expression -> term .)
    LBRACE          reduce using rule 37 (expression -> term .)
    TIMES           shift and go to state 64
    DIVIDE          shift and go to state 65

    multiplyingOperator            shift and go to state 63

state 32

    (40) expression -> addingOperator . term
    (44) term -> . factor
    (45) term -> . term multiplyingOperator factor
    (38) factor -> . ID DOT ISALPHA LPAREN RPAREN
    (39) factor -> . ID DOT APPEND LPAREN expression RPAREN
    (48) factor -> . ID
    (49) factor -> . STRING
    (50) factor -> . NUMBER
    (51) factor -> . FALSE
    (52) factor -> . TRUE
    (53) factor -> . LPAREN expression RPAREN

    ID              shift and go to state 36
    STRING          shift and go to state 38
    NUMBER          shift and go to state 39
    FALSE           shift and go to state 40
    TRUE            shift and go to state 41
    LPAREN          shift and go to state 37

    term                           shift and go to state 66
    factor                         shift and go to state 33

state 33

    (44) term -> factor .

    TIMES           reduce using rule 44 (term -> factor .)
    DIVIDE          reduce using rule 44 (term -> factor .)
    EQUALV          reduce using rule 44 (term -> factor .)
    LT              reduce using rule 44 (term -> factor .)
    GT              reduce using rule 44 (term -> factor .)
    LTE             reduce using rule 44 (term -> factor .)
    GTE             reduce using rule 44 (term -> factor .)
    PLUS            reduce using rule 44 (term -> factor .)
    MINUS           reduce using rule 44 (term -> factor .)
    ID              reduce using rule 44 (term -> factor .)
    INPUT           reduce using rule 44 (term -> factor .)
    PRINT           reduce using rule 44 (term -> factor .)
    IF              reduce using rule 44 (term -> factor .)
    WHILE           reduce using rule 44 (term -> factor .)
    FOR             reduce using rule 44 (term -> factor .)
    SEMICOLON       reduce using rule 44 (term -> factor .)
    $end            reduce using rule 44 (term -> factor .)
    RBRACE          reduce using rule 44 (term -> factor .)
    RPAREN          reduce using rule 44 (term -> factor .)
    COMMA           reduce using rule 44 (term -> factor .)
    RBRACKET        reduce using rule 44 (term -> factor .)
    LBRACE          reduce using rule 44 (term -> factor .)


state 34

    (42) addingOperator -> PLUS .

    ID              reduce using rule 42 (addingOperator -> PLUS .)
    STRING          reduce using rule 42 (addingOperator -> PLUS .)
    NUMBER          reduce using rule 42 (addingOperator -> PLUS .)
    FALSE           reduce using rule 42 (addingOperator -> PLUS .)
    TRUE            reduce using rule 42 (addingOperator -> PLUS .)
    LPAREN          reduce using rule 42 (addingOperator -> PLUS .)


state 35

    (43) addingOperator -> MINUS .

    ID              reduce using rule 43 (addingOperator -> MINUS .)
    STRING          reduce using rule 43 (addingOperator -> MINUS .)
    NUMBER          reduce using rule 43 (addingOperator -> MINUS .)
    FALSE           reduce using rule 43 (addingOperator -> MINUS .)
    TRUE            reduce using rule 43 (addingOperator -> MINUS .)
    LPAREN          reduce using rule 43 (addingOperator -> MINUS .)


state 36

    (38) factor -> ID . DOT ISALPHA LPAREN RPAREN
    (39) factor -> ID . DOT APPEND LPAREN expression RPAREN
    (48) factor -> ID .

    DOT             shift and go to state 67
    TIMES           reduce using rule 48 (factor -> ID .)
    DIVIDE          reduce using rule 48 (factor -> ID .)
    EQUALV          reduce using rule 48 (factor -> ID .)
    LT              reduce using rule 48 (factor -> ID .)
    GT              reduce using rule 48 (factor -> ID .)
    LTE             reduce using rule 48 (factor -> ID .)
    GTE             reduce using rule 48 (factor -> ID .)
    PLUS            reduce using rule 48 (factor -> ID .)
    MINUS           reduce using rule 48 (factor -> ID .)
    ID              reduce using rule 48 (factor -> ID .)
    INPUT           reduce using rule 48 (factor -> ID .)
    PRINT           reduce using rule 48 (factor -> ID .)
    IF              reduce using rule 48 (factor -> ID .)
    WHILE           reduce using rule 48 (factor -> ID .)
    FOR             reduce using rule 48 (factor -> ID .)
    SEMICOLON       reduce using rule 48 (factor -> ID .)
    $end            reduce using rule 48 (factor -> ID .)
    RBRACE          reduce using rule 48 (factor -> ID .)
    RPAREN          reduce using rule 48 (factor -> ID .)
    COMMA           reduce using rule 48 (factor -> ID .)
    RBRACKET        reduce using rule 48 (factor -> ID .)
    LBRACE          reduce using rule 48 (factor -> ID .)


state 37

    (53) factor -> LPAREN . expression RPAREN
    (37) expression -> . term
    (40) expression -> . addingOperator term
    (41) expression -> . expression addingOperator term
    (44) term -> . factor
    (45) term -> . term multiplyingOperator factor
    (42) addingOperator -> . PLUS
    (43) addingOperator -> . MINUS
    (38) factor -> . ID DOT ISALPHA LPAREN RPAREN
    (39) factor -> . ID DOT APPEND LPAREN expression RPAREN
    (48) factor -> . ID
    (49) factor -> . STRING
    (50) factor -> . NUMBER
    (51) factor -> . FALSE
    (52) factor -> . TRUE
    (53) factor -> . LPAREN expression RPAREN

    PLUS            shift and go to state 34
    MINUS           shift and go to state 35
    ID              shift and go to state 36
    STRING          shift and go to state 38
    NUMBER          shift and go to state 39
    FALSE           shift and go to state 40
    TRUE            shift and go to state 41
    LPAREN          shift and go to state 37

    expression                     shift and go to state 68
    term                           shift and go to state 31
    addingOperator                 shift and go to state 32
    factor                         shift and go to state 33

state 38

    (49) factor -> STRING .

    TIMES           reduce using rule 49 (factor -> STRING .)
    DIVIDE          reduce using rule 49 (factor -> STRING .)
    EQUALV          reduce using rule 49 (factor -> STRING .)
    LT              reduce using rule 49 (factor -> STRING .)
    GT              reduce using rule 49 (factor -> STRING .)
    LTE             reduce using rule 49 (factor -> STRING .)
    GTE             reduce using rule 49 (factor -> STRING .)
    PLUS            reduce using rule 49 (factor -> STRING .)
    MINUS           reduce using rule 49 (factor -> STRING .)
    ID              reduce using rule 49 (factor -> STRING .)
    INPUT           reduce using rule 49 (factor -> STRING .)
    PRINT           reduce using rule 49 (factor -> STRING .)
    IF              reduce using rule 49 (factor -> STRING .)
    WHILE           reduce using rule 49 (factor -> STRING .)
    FOR             reduce using rule 49 (factor -> STRING .)
    SEMICOLON       reduce using rule 49 (factor -> STRING .)
    $end            reduce using rule 49 (factor -> STRING .)
    RBRACE          reduce using rule 49 (factor -> STRING .)
    RPAREN          reduce using rule 49 (factor -> STRING .)
    COMMA           reduce using rule 49 (factor -> STRING .)
    RBRACKET        reduce using rule 49 (factor -> STRING .)
    LBRACE          reduce using rule 49 (factor -> STRING .)


state 39

    (50) factor -> NUMBER .

    TIMES           reduce using rule 50 (factor -> NUMBER .)
    DIVIDE          reduce using rule 50 (factor -> NUMBER .)
    EQUALV          reduce using rule 50 (factor -> NUMBER .)
    LT              reduce using rule 50 (factor -> NUMBER .)
    GT              reduce using rule 50 (factor -> NUMBER .)
    LTE             reduce using rule 50 (factor -> NUMBER .)
    GTE             reduce using rule 50 (factor -> NUMBER .)
    PLUS            reduce using rule 50 (factor -> NUMBER .)
    MINUS           reduce using rule 50 (factor -> NUMBER .)
    ID              reduce using rule 50 (factor -> NUMBER .)
    INPUT           reduce using rule 50 (factor -> NUMBER .)
    PRINT           reduce using rule 50 (factor -> NUMBER .)
    IF              reduce using rule 50 (factor -> NUMBER .)
    WHILE           reduce using rule 50 (factor -> NUMBER .)
    FOR             reduce using rule 50 (factor -> NUMBER .)
    SEMICOLON       reduce using rule 50 (factor -> NUMBER .)
    $end            reduce using rule 50 (factor -> NUMBER .)
    RBRACE          reduce using rule 50 (factor -> NUMBER .)
    RPAREN          reduce using rule 50 (factor -> NUMBER .)
    COMMA           reduce using rule 50 (factor -> NUMBER .)
    RBRACKET        reduce using rule 50 (factor -> NUMBER .)
    LBRACE          reduce using rule 50 (factor -> NUMBER .)


state 40

    (51) factor -> FALSE .

    TIMES           reduce using rule 51 (factor -> FALSE .)
    DIVIDE          reduce using rule 51 (factor -> FALSE .)
    EQUALV          reduce using rule 51 (factor -> FALSE .)
    LT              reduce using rule 51 (factor -> FALSE .)
    GT              reduce using rule 51 (factor -> FALSE .)
    LTE             reduce using rule 51 (factor -> FALSE .)
    GTE             reduce using rule 51 (factor -> FALSE .)
    PLUS            reduce using rule 51 (factor -> FALSE .)
    MINUS           reduce using rule 51 (factor -> FALSE .)
    ID              reduce using rule 51 (factor -> FALSE .)
    INPUT           reduce using rule 51 (factor -> FALSE .)
    PRINT           reduce using rule 51 (factor -> FALSE .)
    IF              reduce using rule 51 (factor -> FALSE .)
    WHILE           reduce using rule 51 (factor -> FALSE .)
    FOR             reduce using rule 51 (factor -> FALSE .)
    SEMICOLON       reduce using rule 51 (factor -> FALSE .)
    $end            reduce using rule 51 (factor -> FALSE .)
    RBRACE          reduce using rule 51 (factor -> FALSE .)
    RPAREN          reduce using rule 51 (factor -> FALSE .)
    COMMA           reduce using rule 51 (factor -> FALSE .)
    RBRACKET        reduce using rule 51 (factor -> FALSE .)
    LBRACE          reduce using rule 51 (factor -> FALSE .)


state 41

    (52) factor -> TRUE .

    TIMES           reduce using rule 52 (factor -> TRUE .)
    DIVIDE          reduce using rule 52 (factor -> TRUE .)
    EQUALV          reduce using rule 52 (factor -> TRUE .)
    LT              reduce using rule 52 (factor -> TRUE .)
    GT              reduce using rule 52 (factor -> TRUE .)
    LTE             reduce using rule 52 (factor -> TRUE .)
    GTE             reduce using rule 52 (factor -> TRUE .)
    PLUS            reduce using rule 52 (factor -> TRUE .)
    MINUS           reduce using rule 52 (factor -> TRUE .)
    ID              reduce using rule 52 (factor -> TRUE .)
    INPUT           reduce using rule 52 (factor -> TRUE .)
    PRINT           reduce using rule 52 (factor -> TRUE .)
    IF              reduce using rule 52 (factor -> TRUE .)
    WHILE           reduce using rule 52 (factor -> TRUE .)
    FOR             reduce using rule 52 (factor -> TRUE .)
    SEMICOLON       reduce using rule 52 (factor -> TRUE .)
    $end            reduce using rule 52 (factor -> TRUE .)
    RBRACE          reduce using rule 52 (factor -> TRUE .)
    RPAREN          reduce using rule 52 (factor -> TRUE .)
    COMMA           reduce using rule 52 (factor -> TRUE .)
    RBRACKET        reduce using rule 52 (factor -> TRUE .)
    LBRACE          reduce using rule 52 (factor -> TRUE .)


state 42

    (22) statement -> WHILE condition . LBRACE statement RBRACE

    LBRACE          shift and go to state 69


state 43

    (23) statement -> FOR ID . EQUALS NUMBER SEMICOLON condition SEMICOLON ID PLUSPLUS LBRACE statement RBRACE
    (24) statement -> FOR ID . IN ID LBRACE statement RBRACE

    EQUALS          shift and go to state 70
    IN              shift and go to state 71


state 44

    (11) varDecl -> VAR identList SEMICOLON .

    ID              reduce using rule 11 (varDecl -> VAR identList SEMICOLON .)
    INPUT           reduce using rule 11 (varDecl -> VAR identList SEMICOLON .)
    PRINT           reduce using rule 11 (varDecl -> VAR identList SEMICOLON .)
    IF              reduce using rule 11 (varDecl -> VAR identList SEMICOLON .)
    WHILE           reduce using rule 11 (varDecl -> VAR identList SEMICOLON .)
    FOR             reduce using rule 11 (varDecl -> VAR identList SEMICOLON .)
    SEMICOLON       reduce using rule 11 (varDecl -> VAR identList SEMICOLON .)
    $end            reduce using rule 11 (varDecl -> VAR identList SEMICOLON .)


state 45

    (14) identList -> identList COMMA . ID

    ID              shift and go to state 72


state 46

    (10) constAssignmentList -> constAssignmentList COMMA ID . EQUALS NUMBER

    EQUALS          shift and go to state 73


state 47

    (5) constAssignmentList -> ID EQUALS NUMBER .

    SEMICOLON       reduce using rule 5 (constAssignmentList -> ID EQUALS NUMBER .)
    COMMA           reduce using rule 5 (constAssignmentList -> ID EQUALS NUMBER .)


state 48

    (30) statementList -> statementList SEMICOLON . statement
    (6) statement -> . ID EQUALS LBRACKET elements RBRACKET
    (7) statement -> . ID EQUALS LBRACKET RBRACKET
    (15) statement -> . INPUT LPAREN STRING RPAREN
    (16) statement -> . ID EQUALS INPUT LPAREN STRING RPAREN
    (17) statement -> . PRINT LPAREN STRING RPAREN
    (18) statement -> . PRINT LPAREN expression RPAREN
    (19) statement -> . PRINT LPAREN expression COMMA STRING COMMA expression RPAREN
    (20) statement -> . ID EQUALS expression
    (21) statement -> . IF condition LBRACE statement RBRACE statementIF
    (22) statement -> . WHILE condition LBRACE statement RBRACE
    (23) statement -> . FOR ID EQUALS NUMBER SEMICOLON condition SEMICOLON ID PLUSPLUS LBRACE statement RBRACE
    (24) statement -> . FOR ID IN ID LBRACE statement RBRACE
    (25) statement -> . empty
    (54) empty -> .

    ID              shift and go to state 12
    INPUT           shift and go to state 13
    PRINT           shift and go to state 14
    IF              shift and go to state 15
    WHILE           shift and go to state 16
    FOR             shift and go to state 17
    SEMICOLON       reduce using rule 54 (empty -> .)
    $end            reduce using rule 54 (empty -> .)

    statement                      shift and go to state 74
    empty                          shift and go to state 18

state 49

    (6) statement -> ID EQUALS LBRACKET . elements RBRACKET
    (7) statement -> ID EQUALS LBRACKET . RBRACKET
    (8) elements -> . expression
    (9) elements -> . expression COMMA elements
    (37) expression -> . term
    (40) expression -> . addingOperator term
    (41) expression -> . expression addingOperator term
    (44) term -> . factor
    (45) term -> . term multiplyingOperator factor
    (42) addingOperator -> . PLUS
    (43) addingOperator -> . MINUS
    (38) factor -> . ID DOT ISALPHA LPAREN RPAREN
    (39) factor -> . ID DOT APPEND LPAREN expression RPAREN
    (48) factor -> . ID
    (49) factor -> . STRING
    (50) factor -> . NUMBER
    (51) factor -> . FALSE
    (52) factor -> . TRUE
    (53) factor -> . LPAREN expression RPAREN

    RBRACKET        shift and go to state 76
    PLUS            shift and go to state 34
    MINUS           shift and go to state 35
    ID              shift and go to state 36
    STRING          shift and go to state 38
    NUMBER          shift and go to state 39
    FALSE           shift and go to state 40
    TRUE            shift and go to state 41
    LPAREN          shift and go to state 37

    elements                       shift and go to state 75
    expression                     shift and go to state 77
    term                           shift and go to state 31
    addingOperator                 shift and go to state 32
    factor                         shift and go to state 33

state 50

    (16) statement -> ID EQUALS INPUT . LPAREN STRING RPAREN

    LPAREN          shift and go to state 78


state 51

    (20) statement -> ID EQUALS expression .
    (41) expression -> expression . addingOperator term
    (42) addingOperator -> . PLUS
    (43) addingOperator -> . MINUS

    ID              reduce using rule 20 (statement -> ID EQUALS expression .)
    INPUT           reduce using rule 20 (statement -> ID EQUALS expression .)
    PRINT           reduce using rule 20 (statement -> ID EQUALS expression .)
    IF              reduce using rule 20 (statement -> ID EQUALS expression .)
    WHILE           reduce using rule 20 (statement -> ID EQUALS expression .)
    FOR             reduce using rule 20 (statement -> ID EQUALS expression .)
    SEMICOLON       reduce using rule 20 (statement -> ID EQUALS expression .)
    $end            reduce using rule 20 (statement -> ID EQUALS expression .)
    RBRACE          reduce using rule 20 (statement -> ID EQUALS expression .)
    PLUS            shift and go to state 34
    MINUS           shift and go to state 35

    addingOperator                 shift and go to state 57

state 52

    (15) statement -> INPUT LPAREN STRING . RPAREN

    RPAREN          shift and go to state 79


state 53

    (17) statement -> PRINT LPAREN STRING . RPAREN
    (49) factor -> STRING .

  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 80
    TIMES           reduce using rule 49 (factor -> STRING .)
    DIVIDE          reduce using rule 49 (factor -> STRING .)
    COMMA           reduce using rule 49 (factor -> STRING .)
    PLUS            reduce using rule 49 (factor -> STRING .)
    MINUS           reduce using rule 49 (factor -> STRING .)

  ! RPAREN          [ reduce using rule 49 (factor -> STRING .) ]


state 54

    (18) statement -> PRINT LPAREN expression . RPAREN
    (19) statement -> PRINT LPAREN expression . COMMA STRING COMMA expression RPAREN
    (41) expression -> expression . addingOperator term
    (42) addingOperator -> . PLUS
    (43) addingOperator -> . MINUS

    RPAREN          shift and go to state 81
    COMMA           shift and go to state 82
    PLUS            shift and go to state 34
    MINUS           shift and go to state 35

    addingOperator                 shift and go to state 57

state 55

    (21) statement -> IF condition LBRACE . statement RBRACE statementIF
    (6) statement -> . ID EQUALS LBRACKET elements RBRACKET
    (7) statement -> . ID EQUALS LBRACKET RBRACKET
    (15) statement -> . INPUT LPAREN STRING RPAREN
    (16) statement -> . ID EQUALS INPUT LPAREN STRING RPAREN
    (17) statement -> . PRINT LPAREN STRING RPAREN
    (18) statement -> . PRINT LPAREN expression RPAREN
    (19) statement -> . PRINT LPAREN expression COMMA STRING COMMA expression RPAREN
    (20) statement -> . ID EQUALS expression
    (21) statement -> . IF condition LBRACE statement RBRACE statementIF
    (22) statement -> . WHILE condition LBRACE statement RBRACE
    (23) statement -> . FOR ID EQUALS NUMBER SEMICOLON condition SEMICOLON ID PLUSPLUS LBRACE statement RBRACE
    (24) statement -> . FOR ID IN ID LBRACE statement RBRACE
    (25) statement -> . empty
    (54) empty -> .

    ID              shift and go to state 12
    INPUT           shift and go to state 13
    PRINT           shift and go to state 14
    IF              shift and go to state 15
    WHILE           shift and go to state 16
    FOR             shift and go to state 17
    RBRACE          reduce using rule 54 (empty -> .)

    statement                      shift and go to state 83
    empty                          shift and go to state 18

state 56

    (31) condition -> expression relation . expression
    (37) expression -> . term
    (40) expression -> . addingOperator term
    (41) expression -> . expression addingOperator term
    (44) term -> . factor
    (45) term -> . term multiplyingOperator factor
    (42) addingOperator -> . PLUS
    (43) addingOperator -> . MINUS
    (38) factor -> . ID DOT ISALPHA LPAREN RPAREN
    (39) factor -> . ID DOT APPEND LPAREN expression RPAREN
    (48) factor -> . ID
    (49) factor -> . STRING
    (50) factor -> . NUMBER
    (51) factor -> . FALSE
    (52) factor -> . TRUE
    (53) factor -> . LPAREN expression RPAREN

    PLUS            shift and go to state 34
    MINUS           shift and go to state 35
    ID              shift and go to state 36
    STRING          shift and go to state 38
    NUMBER          shift and go to state 39
    FALSE           shift and go to state 40
    TRUE            shift and go to state 41
    LPAREN          shift and go to state 37

    expression                     shift and go to state 84
    term                           shift and go to state 31
    addingOperator                 shift and go to state 32
    factor                         shift and go to state 33

state 57

    (41) expression -> expression addingOperator . term
    (44) term -> . factor
    (45) term -> . term multiplyingOperator factor
    (38) factor -> . ID DOT ISALPHA LPAREN RPAREN
    (39) factor -> . ID DOT APPEND LPAREN expression RPAREN
    (48) factor -> . ID
    (49) factor -> . STRING
    (50) factor -> . NUMBER
    (51) factor -> . FALSE
    (52) factor -> . TRUE
    (53) factor -> . LPAREN expression RPAREN

    ID              shift and go to state 36
    STRING          shift and go to state 38
    NUMBER          shift and go to state 39
    FALSE           shift and go to state 40
    TRUE            shift and go to state 41
    LPAREN          shift and go to state 37

    term                           shift and go to state 85
    factor                         shift and go to state 33

state 58

    (32) relation -> EQUALV .

    PLUS            reduce using rule 32 (relation -> EQUALV .)
    MINUS           reduce using rule 32 (relation -> EQUALV .)
    ID              reduce using rule 32 (relation -> EQUALV .)
    STRING          reduce using rule 32 (relation -> EQUALV .)
    NUMBER          reduce using rule 32 (relation -> EQUALV .)
    FALSE           reduce using rule 32 (relation -> EQUALV .)
    TRUE            reduce using rule 32 (relation -> EQUALV .)
    LPAREN          reduce using rule 32 (relation -> EQUALV .)


state 59

    (33) relation -> LT .

    PLUS            reduce using rule 33 (relation -> LT .)
    MINUS           reduce using rule 33 (relation -> LT .)
    ID              reduce using rule 33 (relation -> LT .)
    STRING          reduce using rule 33 (relation -> LT .)
    NUMBER          reduce using rule 33 (relation -> LT .)
    FALSE           reduce using rule 33 (relation -> LT .)
    TRUE            reduce using rule 33 (relation -> LT .)
    LPAREN          reduce using rule 33 (relation -> LT .)


state 60

    (34) relation -> GT .

    PLUS            reduce using rule 34 (relation -> GT .)
    MINUS           reduce using rule 34 (relation -> GT .)
    ID              reduce using rule 34 (relation -> GT .)
    STRING          reduce using rule 34 (relation -> GT .)
    NUMBER          reduce using rule 34 (relation -> GT .)
    FALSE           reduce using rule 34 (relation -> GT .)
    TRUE            reduce using rule 34 (relation -> GT .)
    LPAREN          reduce using rule 34 (relation -> GT .)


state 61

    (35) relation -> LTE .

    PLUS            reduce using rule 35 (relation -> LTE .)
    MINUS           reduce using rule 35 (relation -> LTE .)
    ID              reduce using rule 35 (relation -> LTE .)
    STRING          reduce using rule 35 (relation -> LTE .)
    NUMBER          reduce using rule 35 (relation -> LTE .)
    FALSE           reduce using rule 35 (relation -> LTE .)
    TRUE            reduce using rule 35 (relation -> LTE .)
    LPAREN          reduce using rule 35 (relation -> LTE .)


state 62

    (36) relation -> GTE .

    PLUS            reduce using rule 36 (relation -> GTE .)
    MINUS           reduce using rule 36 (relation -> GTE .)
    ID              reduce using rule 36 (relation -> GTE .)
    STRING          reduce using rule 36 (relation -> GTE .)
    NUMBER          reduce using rule 36 (relation -> GTE .)
    FALSE           reduce using rule 36 (relation -> GTE .)
    TRUE            reduce using rule 36 (relation -> GTE .)
    LPAREN          reduce using rule 36 (relation -> GTE .)


state 63

    (45) term -> term multiplyingOperator . factor
    (38) factor -> . ID DOT ISALPHA LPAREN RPAREN
    (39) factor -> . ID DOT APPEND LPAREN expression RPAREN
    (48) factor -> . ID
    (49) factor -> . STRING
    (50) factor -> . NUMBER
    (51) factor -> . FALSE
    (52) factor -> . TRUE
    (53) factor -> . LPAREN expression RPAREN

    ID              shift and go to state 36
    STRING          shift and go to state 38
    NUMBER          shift and go to state 39
    FALSE           shift and go to state 40
    TRUE            shift and go to state 41
    LPAREN          shift and go to state 37

    factor                         shift and go to state 86

state 64

    (46) multiplyingOperator -> TIMES .

    ID              reduce using rule 46 (multiplyingOperator -> TIMES .)
    STRING          reduce using rule 46 (multiplyingOperator -> TIMES .)
    NUMBER          reduce using rule 46 (multiplyingOperator -> TIMES .)
    FALSE           reduce using rule 46 (multiplyingOperator -> TIMES .)
    TRUE            reduce using rule 46 (multiplyingOperator -> TIMES .)
    LPAREN          reduce using rule 46 (multiplyingOperator -> TIMES .)


state 65

    (47) multiplyingOperator -> DIVIDE .

    ID              reduce using rule 47 (multiplyingOperator -> DIVIDE .)
    STRING          reduce using rule 47 (multiplyingOperator -> DIVIDE .)
    NUMBER          reduce using rule 47 (multiplyingOperator -> DIVIDE .)
    FALSE           reduce using rule 47 (multiplyingOperator -> DIVIDE .)
    TRUE            reduce using rule 47 (multiplyingOperator -> DIVIDE .)
    LPAREN          reduce using rule 47 (multiplyingOperator -> DIVIDE .)


state 66

    (40) expression -> addingOperator term .
    (45) term -> term . multiplyingOperator factor
    (46) multiplyingOperator -> . TIMES
    (47) multiplyingOperator -> . DIVIDE

    EQUALV          reduce using rule 40 (expression -> addingOperator term .)
    LT              reduce using rule 40 (expression -> addingOperator term .)
    GT              reduce using rule 40 (expression -> addingOperator term .)
    LTE             reduce using rule 40 (expression -> addingOperator term .)
    GTE             reduce using rule 40 (expression -> addingOperator term .)
    PLUS            reduce using rule 40 (expression -> addingOperator term .)
    MINUS           reduce using rule 40 (expression -> addingOperator term .)
    ID              reduce using rule 40 (expression -> addingOperator term .)
    INPUT           reduce using rule 40 (expression -> addingOperator term .)
    PRINT           reduce using rule 40 (expression -> addingOperator term .)
    IF              reduce using rule 40 (expression -> addingOperator term .)
    WHILE           reduce using rule 40 (expression -> addingOperator term .)
    FOR             reduce using rule 40 (expression -> addingOperator term .)
    SEMICOLON       reduce using rule 40 (expression -> addingOperator term .)
    $end            reduce using rule 40 (expression -> addingOperator term .)
    RBRACE          reduce using rule 40 (expression -> addingOperator term .)
    RPAREN          reduce using rule 40 (expression -> addingOperator term .)
    COMMA           reduce using rule 40 (expression -> addingOperator term .)
    RBRACKET        reduce using rule 40 (expression -> addingOperator term .)
    LBRACE          reduce using rule 40 (expression -> addingOperator term .)
    TIMES           shift and go to state 64
    DIVIDE          shift and go to state 65

    multiplyingOperator            shift and go to state 63

state 67

    (38) factor -> ID DOT . ISALPHA LPAREN RPAREN
    (39) factor -> ID DOT . APPEND LPAREN expression RPAREN

    ISALPHA         shift and go to state 87
    APPEND          shift and go to state 88


state 68

    (53) factor -> LPAREN expression . RPAREN
    (41) expression -> expression . addingOperator term
    (42) addingOperator -> . PLUS
    (43) addingOperator -> . MINUS

    RPAREN          shift and go to state 89
    PLUS            shift and go to state 34
    MINUS           shift and go to state 35

    addingOperator                 shift and go to state 57

state 69

    (22) statement -> WHILE condition LBRACE . statement RBRACE
    (6) statement -> . ID EQUALS LBRACKET elements RBRACKET
    (7) statement -> . ID EQUALS LBRACKET RBRACKET
    (15) statement -> . INPUT LPAREN STRING RPAREN
    (16) statement -> . ID EQUALS INPUT LPAREN STRING RPAREN
    (17) statement -> . PRINT LPAREN STRING RPAREN
    (18) statement -> . PRINT LPAREN expression RPAREN
    (19) statement -> . PRINT LPAREN expression COMMA STRING COMMA expression RPAREN
    (20) statement -> . ID EQUALS expression
    (21) statement -> . IF condition LBRACE statement RBRACE statementIF
    (22) statement -> . WHILE condition LBRACE statement RBRACE
    (23) statement -> . FOR ID EQUALS NUMBER SEMICOLON condition SEMICOLON ID PLUSPLUS LBRACE statement RBRACE
    (24) statement -> . FOR ID IN ID LBRACE statement RBRACE
    (25) statement -> . empty
    (54) empty -> .

    ID              shift and go to state 12
    INPUT           shift and go to state 13
    PRINT           shift and go to state 14
    IF              shift and go to state 15
    WHILE           shift and go to state 16
    FOR             shift and go to state 17
    RBRACE          reduce using rule 54 (empty -> .)

    statement                      shift and go to state 90
    empty                          shift and go to state 18

state 70

    (23) statement -> FOR ID EQUALS . NUMBER SEMICOLON condition SEMICOLON ID PLUSPLUS LBRACE statement RBRACE

    NUMBER          shift and go to state 91


state 71

    (24) statement -> FOR ID IN . ID LBRACE statement RBRACE

    ID              shift and go to state 92


state 72

    (14) identList -> identList COMMA ID .

    SEMICOLON       reduce using rule 14 (identList -> identList COMMA ID .)
    COMMA           reduce using rule 14 (identList -> identList COMMA ID .)


state 73

    (10) constAssignmentList -> constAssignmentList COMMA ID EQUALS . NUMBER

    NUMBER          shift and go to state 93


state 74

    (30) statementList -> statementList SEMICOLON statement .

    SEMICOLON       reduce using rule 30 (statementList -> statementList SEMICOLON statement .)
    $end            reduce using rule 30 (statementList -> statementList SEMICOLON statement .)


state 75

    (6) statement -> ID EQUALS LBRACKET elements . RBRACKET

    RBRACKET        shift and go to state 94


state 76

    (7) statement -> ID EQUALS LBRACKET RBRACKET .

    ID              reduce using rule 7 (statement -> ID EQUALS LBRACKET RBRACKET .)
    INPUT           reduce using rule 7 (statement -> ID EQUALS LBRACKET RBRACKET .)
    PRINT           reduce using rule 7 (statement -> ID EQUALS LBRACKET RBRACKET .)
    IF              reduce using rule 7 (statement -> ID EQUALS LBRACKET RBRACKET .)
    WHILE           reduce using rule 7 (statement -> ID EQUALS LBRACKET RBRACKET .)
    FOR             reduce using rule 7 (statement -> ID EQUALS LBRACKET RBRACKET .)
    SEMICOLON       reduce using rule 7 (statement -> ID EQUALS LBRACKET RBRACKET .)
    $end            reduce using rule 7 (statement -> ID EQUALS LBRACKET RBRACKET .)
    RBRACE          reduce using rule 7 (statement -> ID EQUALS LBRACKET RBRACKET .)


state 77

    (8) elements -> expression .
    (9) elements -> expression . COMMA elements
    (41) expression -> expression . addingOperator term
    (42) addingOperator -> . PLUS
    (43) addingOperator -> . MINUS

    RBRACKET        reduce using rule 8 (elements -> expression .)
    COMMA           shift and go to state 95
    PLUS            shift and go to state 34
    MINUS           shift and go to state 35

    addingOperator                 shift and go to state 57

state 78

    (16) statement -> ID EQUALS INPUT LPAREN . STRING RPAREN

    STRING          shift and go to state 96


state 79

    (15) statement -> INPUT LPAREN STRING RPAREN .

    ID              reduce using rule 15 (statement -> INPUT LPAREN STRING RPAREN .)
    INPUT           reduce using rule 15 (statement -> INPUT LPAREN STRING RPAREN .)
    PRINT           reduce using rule 15 (statement -> INPUT LPAREN STRING RPAREN .)
    IF              reduce using rule 15 (statement -> INPUT LPAREN STRING RPAREN .)
    WHILE           reduce using rule 15 (statement -> INPUT LPAREN STRING RPAREN .)
    FOR             reduce using rule 15 (statement -> INPUT LPAREN STRING RPAREN .)
    SEMICOLON       reduce using rule 15 (statement -> INPUT LPAREN STRING RPAREN .)
    $end            reduce using rule 15 (statement -> INPUT LPAREN STRING RPAREN .)
    RBRACE          reduce using rule 15 (statement -> INPUT LPAREN STRING RPAREN .)


state 80

    (17) statement -> PRINT LPAREN STRING RPAREN .

    ID              reduce using rule 17 (statement -> PRINT LPAREN STRING RPAREN .)
    INPUT           reduce using rule 17 (statement -> PRINT LPAREN STRING RPAREN .)
    PRINT           reduce using rule 17 (statement -> PRINT LPAREN STRING RPAREN .)
    IF              reduce using rule 17 (statement -> PRINT LPAREN STRING RPAREN .)
    WHILE           reduce using rule 17 (statement -> PRINT LPAREN STRING RPAREN .)
    FOR             reduce using rule 17 (statement -> PRINT LPAREN STRING RPAREN .)
    SEMICOLON       reduce using rule 17 (statement -> PRINT LPAREN STRING RPAREN .)
    $end            reduce using rule 17 (statement -> PRINT LPAREN STRING RPAREN .)
    RBRACE          reduce using rule 17 (statement -> PRINT LPAREN STRING RPAREN .)


state 81

    (18) statement -> PRINT LPAREN expression RPAREN .

    ID              reduce using rule 18 (statement -> PRINT LPAREN expression RPAREN .)
    INPUT           reduce using rule 18 (statement -> PRINT LPAREN expression RPAREN .)
    PRINT           reduce using rule 18 (statement -> PRINT LPAREN expression RPAREN .)
    IF              reduce using rule 18 (statement -> PRINT LPAREN expression RPAREN .)
    WHILE           reduce using rule 18 (statement -> PRINT LPAREN expression RPAREN .)
    FOR             reduce using rule 18 (statement -> PRINT LPAREN expression RPAREN .)
    SEMICOLON       reduce using rule 18 (statement -> PRINT LPAREN expression RPAREN .)
    $end            reduce using rule 18 (statement -> PRINT LPAREN expression RPAREN .)
    RBRACE          reduce using rule 18 (statement -> PRINT LPAREN expression RPAREN .)


state 82

    (19) statement -> PRINT LPAREN expression COMMA . STRING COMMA expression RPAREN

    STRING          shift and go to state 97


state 83

    (21) statement -> IF condition LBRACE statement . RBRACE statementIF

    RBRACE          shift and go to state 98


state 84

    (31) condition -> expression relation expression .
    (41) expression -> expression . addingOperator term
    (42) addingOperator -> . PLUS
    (43) addingOperator -> . MINUS

    LBRACE          reduce using rule 31 (condition -> expression relation expression .)
    SEMICOLON       reduce using rule 31 (condition -> expression relation expression .)
    PLUS            shift and go to state 34
    MINUS           shift and go to state 35

    addingOperator                 shift and go to state 57

state 85

    (41) expression -> expression addingOperator term .
    (45) term -> term . multiplyingOperator factor
    (46) multiplyingOperator -> . TIMES
    (47) multiplyingOperator -> . DIVIDE

    EQUALV          reduce using rule 41 (expression -> expression addingOperator term .)
    LT              reduce using rule 41 (expression -> expression addingOperator term .)
    GT              reduce using rule 41 (expression -> expression addingOperator term .)
    LTE             reduce using rule 41 (expression -> expression addingOperator term .)
    GTE             reduce using rule 41 (expression -> expression addingOperator term .)
    PLUS            reduce using rule 41 (expression -> expression addingOperator term .)
    MINUS           reduce using rule 41 (expression -> expression addingOperator term .)
    ID              reduce using rule 41 (expression -> expression addingOperator term .)
    INPUT           reduce using rule 41 (expression -> expression addingOperator term .)
    PRINT           reduce using rule 41 (expression -> expression addingOperator term .)
    IF              reduce using rule 41 (expression -> expression addingOperator term .)
    WHILE           reduce using rule 41 (expression -> expression addingOperator term .)
    FOR             reduce using rule 41 (expression -> expression addingOperator term .)
    SEMICOLON       reduce using rule 41 (expression -> expression addingOperator term .)
    $end            reduce using rule 41 (expression -> expression addingOperator term .)
    RBRACE          reduce using rule 41 (expression -> expression addingOperator term .)
    RPAREN          reduce using rule 41 (expression -> expression addingOperator term .)
    COMMA           reduce using rule 41 (expression -> expression addingOperator term .)
    RBRACKET        reduce using rule 41 (expression -> expression addingOperator term .)
    LBRACE          reduce using rule 41 (expression -> expression addingOperator term .)
    TIMES           shift and go to state 64
    DIVIDE          shift and go to state 65

    multiplyingOperator            shift and go to state 63

state 86

    (45) term -> term multiplyingOperator factor .

    TIMES           reduce using rule 45 (term -> term multiplyingOperator factor .)
    DIVIDE          reduce using rule 45 (term -> term multiplyingOperator factor .)
    EQUALV          reduce using rule 45 (term -> term multiplyingOperator factor .)
    LT              reduce using rule 45 (term -> term multiplyingOperator factor .)
    GT              reduce using rule 45 (term -> term multiplyingOperator factor .)
    LTE             reduce using rule 45 (term -> term multiplyingOperator factor .)
    GTE             reduce using rule 45 (term -> term multiplyingOperator factor .)
    PLUS            reduce using rule 45 (term -> term multiplyingOperator factor .)
    MINUS           reduce using rule 45 (term -> term multiplyingOperator factor .)
    ID              reduce using rule 45 (term -> term multiplyingOperator factor .)
    INPUT           reduce using rule 45 (term -> term multiplyingOperator factor .)
    PRINT           reduce using rule 45 (term -> term multiplyingOperator factor .)
    IF              reduce using rule 45 (term -> term multiplyingOperator factor .)
    WHILE           reduce using rule 45 (term -> term multiplyingOperator factor .)
    FOR             reduce using rule 45 (term -> term multiplyingOperator factor .)
    SEMICOLON       reduce using rule 45 (term -> term multiplyingOperator factor .)
    $end            reduce using rule 45 (term -> term multiplyingOperator factor .)
    RBRACE          reduce using rule 45 (term -> term multiplyingOperator factor .)
    RPAREN          reduce using rule 45 (term -> term multiplyingOperator factor .)
    COMMA           reduce using rule 45 (term -> term multiplyingOperator factor .)
    RBRACKET        reduce using rule 45 (term -> term multiplyingOperator factor .)
    LBRACE          reduce using rule 45 (term -> term multiplyingOperator factor .)


state 87

    (38) factor -> ID DOT ISALPHA . LPAREN RPAREN

    LPAREN          shift and go to state 99


state 88

    (39) factor -> ID DOT APPEND . LPAREN expression RPAREN

    LPAREN          shift and go to state 100


state 89

    (53) factor -> LPAREN expression RPAREN .

    TIMES           reduce using rule 53 (factor -> LPAREN expression RPAREN .)
    DIVIDE          reduce using rule 53 (factor -> LPAREN expression RPAREN .)
    EQUALV          reduce using rule 53 (factor -> LPAREN expression RPAREN .)
    LT              reduce using rule 53 (factor -> LPAREN expression RPAREN .)
    GT              reduce using rule 53 (factor -> LPAREN expression RPAREN .)
    LTE             reduce using rule 53 (factor -> LPAREN expression RPAREN .)
    GTE             reduce using rule 53 (factor -> LPAREN expression RPAREN .)
    PLUS            reduce using rule 53 (factor -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 53 (factor -> LPAREN expression RPAREN .)
    ID              reduce using rule 53 (factor -> LPAREN expression RPAREN .)
    INPUT           reduce using rule 53 (factor -> LPAREN expression RPAREN .)
    PRINT           reduce using rule 53 (factor -> LPAREN expression RPAREN .)
    IF              reduce using rule 53 (factor -> LPAREN expression RPAREN .)
    WHILE           reduce using rule 53 (factor -> LPAREN expression RPAREN .)
    FOR             reduce using rule 53 (factor -> LPAREN expression RPAREN .)
    SEMICOLON       reduce using rule 53 (factor -> LPAREN expression RPAREN .)
    $end            reduce using rule 53 (factor -> LPAREN expression RPAREN .)
    RBRACE          reduce using rule 53 (factor -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 53 (factor -> LPAREN expression RPAREN .)
    COMMA           reduce using rule 53 (factor -> LPAREN expression RPAREN .)
    RBRACKET        reduce using rule 53 (factor -> LPAREN expression RPAREN .)
    LBRACE          reduce using rule 53 (factor -> LPAREN expression RPAREN .)


state 90

    (22) statement -> WHILE condition LBRACE statement . RBRACE

    RBRACE          shift and go to state 101


state 91

    (23) statement -> FOR ID EQUALS NUMBER . SEMICOLON condition SEMICOLON ID PLUSPLUS LBRACE statement RBRACE

    SEMICOLON       shift and go to state 102


state 92

    (24) statement -> FOR ID IN ID . LBRACE statement RBRACE

    LBRACE          shift and go to state 103


state 93

    (10) constAssignmentList -> constAssignmentList COMMA ID EQUALS NUMBER .

    SEMICOLON       reduce using rule 10 (constAssignmentList -> constAssignmentList COMMA ID EQUALS NUMBER .)
    COMMA           reduce using rule 10 (constAssignmentList -> constAssignmentList COMMA ID EQUALS NUMBER .)


state 94

    (6) statement -> ID EQUALS LBRACKET elements RBRACKET .

    ID              reduce using rule 6 (statement -> ID EQUALS LBRACKET elements RBRACKET .)
    INPUT           reduce using rule 6 (statement -> ID EQUALS LBRACKET elements RBRACKET .)
    PRINT           reduce using rule 6 (statement -> ID EQUALS LBRACKET elements RBRACKET .)
    IF              reduce using rule 6 (statement -> ID EQUALS LBRACKET elements RBRACKET .)
    WHILE           reduce using rule 6 (statement -> ID EQUALS LBRACKET elements RBRACKET .)
    FOR             reduce using rule 6 (statement -> ID EQUALS LBRACKET elements RBRACKET .)
    SEMICOLON       reduce using rule 6 (statement -> ID EQUALS LBRACKET elements RBRACKET .)
    $end            reduce using rule 6 (statement -> ID EQUALS LBRACKET elements RBRACKET .)
    RBRACE          reduce using rule 6 (statement -> ID EQUALS LBRACKET elements RBRACKET .)


state 95

    (9) elements -> expression COMMA . elements
    (8) elements -> . expression
    (9) elements -> . expression COMMA elements
    (37) expression -> . term
    (40) expression -> . addingOperator term
    (41) expression -> . expression addingOperator term
    (44) term -> . factor
    (45) term -> . term multiplyingOperator factor
    (42) addingOperator -> . PLUS
    (43) addingOperator -> . MINUS
    (38) factor -> . ID DOT ISALPHA LPAREN RPAREN
    (39) factor -> . ID DOT APPEND LPAREN expression RPAREN
    (48) factor -> . ID
    (49) factor -> . STRING
    (50) factor -> . NUMBER
    (51) factor -> . FALSE
    (52) factor -> . TRUE
    (53) factor -> . LPAREN expression RPAREN

    PLUS            shift and go to state 34
    MINUS           shift and go to state 35
    ID              shift and go to state 36
    STRING          shift and go to state 38
    NUMBER          shift and go to state 39
    FALSE           shift and go to state 40
    TRUE            shift and go to state 41
    LPAREN          shift and go to state 37

    expression                     shift and go to state 77
    elements                       shift and go to state 104
    term                           shift and go to state 31
    addingOperator                 shift and go to state 32
    factor                         shift and go to state 33

state 96

    (16) statement -> ID EQUALS INPUT LPAREN STRING . RPAREN

    RPAREN          shift and go to state 105


state 97

    (19) statement -> PRINT LPAREN expression COMMA STRING . COMMA expression RPAREN

    COMMA           shift and go to state 106


state 98

    (21) statement -> IF condition LBRACE statement RBRACE . statementIF
    (26) statementIF -> . ELSE LBRACE statement RBRACE
    (27) statementIF -> . ELSE IF condition LBRACE statement RBRACE
    (28) statementIF -> . empty
    (54) empty -> .

    ELSE            shift and go to state 108
    ID              reduce using rule 54 (empty -> .)
    INPUT           reduce using rule 54 (empty -> .)
    PRINT           reduce using rule 54 (empty -> .)
    IF              reduce using rule 54 (empty -> .)
    WHILE           reduce using rule 54 (empty -> .)
    FOR             reduce using rule 54 (empty -> .)
    SEMICOLON       reduce using rule 54 (empty -> .)
    $end            reduce using rule 54 (empty -> .)
    RBRACE          reduce using rule 54 (empty -> .)

    statementIF                    shift and go to state 107
    empty                          shift and go to state 109

state 99

    (38) factor -> ID DOT ISALPHA LPAREN . RPAREN

    RPAREN          shift and go to state 110


state 100

    (39) factor -> ID DOT APPEND LPAREN . expression RPAREN
    (37) expression -> . term
    (40) expression -> . addingOperator term
    (41) expression -> . expression addingOperator term
    (44) term -> . factor
    (45) term -> . term multiplyingOperator factor
    (42) addingOperator -> . PLUS
    (43) addingOperator -> . MINUS
    (38) factor -> . ID DOT ISALPHA LPAREN RPAREN
    (39) factor -> . ID DOT APPEND LPAREN expression RPAREN
    (48) factor -> . ID
    (49) factor -> . STRING
    (50) factor -> . NUMBER
    (51) factor -> . FALSE
    (52) factor -> . TRUE
    (53) factor -> . LPAREN expression RPAREN

    PLUS            shift and go to state 34
    MINUS           shift and go to state 35
    ID              shift and go to state 36
    STRING          shift and go to state 38
    NUMBER          shift and go to state 39
    FALSE           shift and go to state 40
    TRUE            shift and go to state 41
    LPAREN          shift and go to state 37

    expression                     shift and go to state 111
    term                           shift and go to state 31
    addingOperator                 shift and go to state 32
    factor                         shift and go to state 33

state 101

    (22) statement -> WHILE condition LBRACE statement RBRACE .

    ID              reduce using rule 22 (statement -> WHILE condition LBRACE statement RBRACE .)
    INPUT           reduce using rule 22 (statement -> WHILE condition LBRACE statement RBRACE .)
    PRINT           reduce using rule 22 (statement -> WHILE condition LBRACE statement RBRACE .)
    IF              reduce using rule 22 (statement -> WHILE condition LBRACE statement RBRACE .)
    WHILE           reduce using rule 22 (statement -> WHILE condition LBRACE statement RBRACE .)
    FOR             reduce using rule 22 (statement -> WHILE condition LBRACE statement RBRACE .)
    SEMICOLON       reduce using rule 22 (statement -> WHILE condition LBRACE statement RBRACE .)
    $end            reduce using rule 22 (statement -> WHILE condition LBRACE statement RBRACE .)
    RBRACE          reduce using rule 22 (statement -> WHILE condition LBRACE statement RBRACE .)


state 102

    (23) statement -> FOR ID EQUALS NUMBER SEMICOLON . condition SEMICOLON ID PLUSPLUS LBRACE statement RBRACE
    (31) condition -> . expression relation expression
    (37) expression -> . term
    (40) expression -> . addingOperator term
    (41) expression -> . expression addingOperator term
    (44) term -> . factor
    (45) term -> . term multiplyingOperator factor
    (42) addingOperator -> . PLUS
    (43) addingOperator -> . MINUS
    (38) factor -> . ID DOT ISALPHA LPAREN RPAREN
    (39) factor -> . ID DOT APPEND LPAREN expression RPAREN
    (48) factor -> . ID
    (49) factor -> . STRING
    (50) factor -> . NUMBER
    (51) factor -> . FALSE
    (52) factor -> . TRUE
    (53) factor -> . LPAREN expression RPAREN

    PLUS            shift and go to state 34
    MINUS           shift and go to state 35
    ID              shift and go to state 36
    STRING          shift and go to state 38
    NUMBER          shift and go to state 39
    FALSE           shift and go to state 40
    TRUE            shift and go to state 41
    LPAREN          shift and go to state 37

    condition                      shift and go to state 112
    expression                     shift and go to state 30
    term                           shift and go to state 31
    addingOperator                 shift and go to state 32
    factor                         shift and go to state 33

state 103

    (24) statement -> FOR ID IN ID LBRACE . statement RBRACE
    (6) statement -> . ID EQUALS LBRACKET elements RBRACKET
    (7) statement -> . ID EQUALS LBRACKET RBRACKET
    (15) statement -> . INPUT LPAREN STRING RPAREN
    (16) statement -> . ID EQUALS INPUT LPAREN STRING RPAREN
    (17) statement -> . PRINT LPAREN STRING RPAREN
    (18) statement -> . PRINT LPAREN expression RPAREN
    (19) statement -> . PRINT LPAREN expression COMMA STRING COMMA expression RPAREN
    (20) statement -> . ID EQUALS expression
    (21) statement -> . IF condition LBRACE statement RBRACE statementIF
    (22) statement -> . WHILE condition LBRACE statement RBRACE
    (23) statement -> . FOR ID EQUALS NUMBER SEMICOLON condition SEMICOLON ID PLUSPLUS LBRACE statement RBRACE
    (24) statement -> . FOR ID IN ID LBRACE statement RBRACE
    (25) statement -> . empty
    (54) empty -> .

    ID              shift and go to state 12
    INPUT           shift and go to state 13
    PRINT           shift and go to state 14
    IF              shift and go to state 15
    WHILE           shift and go to state 16
    FOR             shift and go to state 17
    RBRACE          reduce using rule 54 (empty -> .)

    statement                      shift and go to state 113
    empty                          shift and go to state 18

state 104

    (9) elements -> expression COMMA elements .

    RBRACKET        reduce using rule 9 (elements -> expression COMMA elements .)


state 105

    (16) statement -> ID EQUALS INPUT LPAREN STRING RPAREN .

    ID              reduce using rule 16 (statement -> ID EQUALS INPUT LPAREN STRING RPAREN .)
    INPUT           reduce using rule 16 (statement -> ID EQUALS INPUT LPAREN STRING RPAREN .)
    PRINT           reduce using rule 16 (statement -> ID EQUALS INPUT LPAREN STRING RPAREN .)
    IF              reduce using rule 16 (statement -> ID EQUALS INPUT LPAREN STRING RPAREN .)
    WHILE           reduce using rule 16 (statement -> ID EQUALS INPUT LPAREN STRING RPAREN .)
    FOR             reduce using rule 16 (statement -> ID EQUALS INPUT LPAREN STRING RPAREN .)
    SEMICOLON       reduce using rule 16 (statement -> ID EQUALS INPUT LPAREN STRING RPAREN .)
    $end            reduce using rule 16 (statement -> ID EQUALS INPUT LPAREN STRING RPAREN .)
    RBRACE          reduce using rule 16 (statement -> ID EQUALS INPUT LPAREN STRING RPAREN .)


state 106

    (19) statement -> PRINT LPAREN expression COMMA STRING COMMA . expression RPAREN
    (37) expression -> . term
    (40) expression -> . addingOperator term
    (41) expression -> . expression addingOperator term
    (44) term -> . factor
    (45) term -> . term multiplyingOperator factor
    (42) addingOperator -> . PLUS
    (43) addingOperator -> . MINUS
    (38) factor -> . ID DOT ISALPHA LPAREN RPAREN
    (39) factor -> . ID DOT APPEND LPAREN expression RPAREN
    (48) factor -> . ID
    (49) factor -> . STRING
    (50) factor -> . NUMBER
    (51) factor -> . FALSE
    (52) factor -> . TRUE
    (53) factor -> . LPAREN expression RPAREN

    PLUS            shift and go to state 34
    MINUS           shift and go to state 35
    ID              shift and go to state 36
    STRING          shift and go to state 38
    NUMBER          shift and go to state 39
    FALSE           shift and go to state 40
    TRUE            shift and go to state 41
    LPAREN          shift and go to state 37

    expression                     shift and go to state 114
    term                           shift and go to state 31
    addingOperator                 shift and go to state 32
    factor                         shift and go to state 33

state 107

    (21) statement -> IF condition LBRACE statement RBRACE statementIF .

    ID              reduce using rule 21 (statement -> IF condition LBRACE statement RBRACE statementIF .)
    INPUT           reduce using rule 21 (statement -> IF condition LBRACE statement RBRACE statementIF .)
    PRINT           reduce using rule 21 (statement -> IF condition LBRACE statement RBRACE statementIF .)
    IF              reduce using rule 21 (statement -> IF condition LBRACE statement RBRACE statementIF .)
    WHILE           reduce using rule 21 (statement -> IF condition LBRACE statement RBRACE statementIF .)
    FOR             reduce using rule 21 (statement -> IF condition LBRACE statement RBRACE statementIF .)
    SEMICOLON       reduce using rule 21 (statement -> IF condition LBRACE statement RBRACE statementIF .)
    $end            reduce using rule 21 (statement -> IF condition LBRACE statement RBRACE statementIF .)
    RBRACE          reduce using rule 21 (statement -> IF condition LBRACE statement RBRACE statementIF .)


state 108

    (26) statementIF -> ELSE . LBRACE statement RBRACE
    (27) statementIF -> ELSE . IF condition LBRACE statement RBRACE

    LBRACE          shift and go to state 115
    IF              shift and go to state 116


state 109

    (28) statementIF -> empty .

    ID              reduce using rule 28 (statementIF -> empty .)
    INPUT           reduce using rule 28 (statementIF -> empty .)
    PRINT           reduce using rule 28 (statementIF -> empty .)
    IF              reduce using rule 28 (statementIF -> empty .)
    WHILE           reduce using rule 28 (statementIF -> empty .)
    FOR             reduce using rule 28 (statementIF -> empty .)
    SEMICOLON       reduce using rule 28 (statementIF -> empty .)
    $end            reduce using rule 28 (statementIF -> empty .)
    RBRACE          reduce using rule 28 (statementIF -> empty .)


state 110

    (38) factor -> ID DOT ISALPHA LPAREN RPAREN .

    TIMES           reduce using rule 38 (factor -> ID DOT ISALPHA LPAREN RPAREN .)
    DIVIDE          reduce using rule 38 (factor -> ID DOT ISALPHA LPAREN RPAREN .)
    EQUALV          reduce using rule 38 (factor -> ID DOT ISALPHA LPAREN RPAREN .)
    LT              reduce using rule 38 (factor -> ID DOT ISALPHA LPAREN RPAREN .)
    GT              reduce using rule 38 (factor -> ID DOT ISALPHA LPAREN RPAREN .)
    LTE             reduce using rule 38 (factor -> ID DOT ISALPHA LPAREN RPAREN .)
    GTE             reduce using rule 38 (factor -> ID DOT ISALPHA LPAREN RPAREN .)
    PLUS            reduce using rule 38 (factor -> ID DOT ISALPHA LPAREN RPAREN .)
    MINUS           reduce using rule 38 (factor -> ID DOT ISALPHA LPAREN RPAREN .)
    ID              reduce using rule 38 (factor -> ID DOT ISALPHA LPAREN RPAREN .)
    INPUT           reduce using rule 38 (factor -> ID DOT ISALPHA LPAREN RPAREN .)
    PRINT           reduce using rule 38 (factor -> ID DOT ISALPHA LPAREN RPAREN .)
    IF              reduce using rule 38 (factor -> ID DOT ISALPHA LPAREN RPAREN .)
    WHILE           reduce using rule 38 (factor -> ID DOT ISALPHA LPAREN RPAREN .)
    FOR             reduce using rule 38 (factor -> ID DOT ISALPHA LPAREN RPAREN .)
    SEMICOLON       reduce using rule 38 (factor -> ID DOT ISALPHA LPAREN RPAREN .)
    $end            reduce using rule 38 (factor -> ID DOT ISALPHA LPAREN RPAREN .)
    RBRACE          reduce using rule 38 (factor -> ID DOT ISALPHA LPAREN RPAREN .)
    RPAREN          reduce using rule 38 (factor -> ID DOT ISALPHA LPAREN RPAREN .)
    COMMA           reduce using rule 38 (factor -> ID DOT ISALPHA LPAREN RPAREN .)
    RBRACKET        reduce using rule 38 (factor -> ID DOT ISALPHA LPAREN RPAREN .)
    LBRACE          reduce using rule 38 (factor -> ID DOT ISALPHA LPAREN RPAREN .)


state 111

    (39) factor -> ID DOT APPEND LPAREN expression . RPAREN
    (41) expression -> expression . addingOperator term
    (42) addingOperator -> . PLUS
    (43) addingOperator -> . MINUS

    RPAREN          shift and go to state 117
    PLUS            shift and go to state 34
    MINUS           shift and go to state 35

    addingOperator                 shift and go to state 57

state 112

    (23) statement -> FOR ID EQUALS NUMBER SEMICOLON condition . SEMICOLON ID PLUSPLUS LBRACE statement RBRACE

    SEMICOLON       shift and go to state 118


state 113

    (24) statement -> FOR ID IN ID LBRACE statement . RBRACE

    RBRACE          shift and go to state 119


state 114

    (19) statement -> PRINT LPAREN expression COMMA STRING COMMA expression . RPAREN
    (41) expression -> expression . addingOperator term
    (42) addingOperator -> . PLUS
    (43) addingOperator -> . MINUS

    RPAREN          shift and go to state 120
    PLUS            shift and go to state 34
    MINUS           shift and go to state 35

    addingOperator                 shift and go to state 57

state 115

    (26) statementIF -> ELSE LBRACE . statement RBRACE
    (6) statement -> . ID EQUALS LBRACKET elements RBRACKET
    (7) statement -> . ID EQUALS LBRACKET RBRACKET
    (15) statement -> . INPUT LPAREN STRING RPAREN
    (16) statement -> . ID EQUALS INPUT LPAREN STRING RPAREN
    (17) statement -> . PRINT LPAREN STRING RPAREN
    (18) statement -> . PRINT LPAREN expression RPAREN
    (19) statement -> . PRINT LPAREN expression COMMA STRING COMMA expression RPAREN
    (20) statement -> . ID EQUALS expression
    (21) statement -> . IF condition LBRACE statement RBRACE statementIF
    (22) statement -> . WHILE condition LBRACE statement RBRACE
    (23) statement -> . FOR ID EQUALS NUMBER SEMICOLON condition SEMICOLON ID PLUSPLUS LBRACE statement RBRACE
    (24) statement -> . FOR ID IN ID LBRACE statement RBRACE
    (25) statement -> . empty
    (54) empty -> .

    ID              shift and go to state 12
    INPUT           shift and go to state 13
    PRINT           shift and go to state 14
    IF              shift and go to state 15
    WHILE           shift and go to state 16
    FOR             shift and go to state 17
    RBRACE          reduce using rule 54 (empty -> .)

    statement                      shift and go to state 121
    empty                          shift and go to state 18

state 116

    (27) statementIF -> ELSE IF . condition LBRACE statement RBRACE
    (31) condition -> . expression relation expression
    (37) expression -> . term
    (40) expression -> . addingOperator term
    (41) expression -> . expression addingOperator term
    (44) term -> . factor
    (45) term -> . term multiplyingOperator factor
    (42) addingOperator -> . PLUS
    (43) addingOperator -> . MINUS
    (38) factor -> . ID DOT ISALPHA LPAREN RPAREN
    (39) factor -> . ID DOT APPEND LPAREN expression RPAREN
    (48) factor -> . ID
    (49) factor -> . STRING
    (50) factor -> . NUMBER
    (51) factor -> . FALSE
    (52) factor -> . TRUE
    (53) factor -> . LPAREN expression RPAREN

    PLUS            shift and go to state 34
    MINUS           shift and go to state 35
    ID              shift and go to state 36
    STRING          shift and go to state 38
    NUMBER          shift and go to state 39
    FALSE           shift and go to state 40
    TRUE            shift and go to state 41
    LPAREN          shift and go to state 37

    condition                      shift and go to state 122
    expression                     shift and go to state 30
    term                           shift and go to state 31
    addingOperator                 shift and go to state 32
    factor                         shift and go to state 33

state 117

    (39) factor -> ID DOT APPEND LPAREN expression RPAREN .

    TIMES           reduce using rule 39 (factor -> ID DOT APPEND LPAREN expression RPAREN .)
    DIVIDE          reduce using rule 39 (factor -> ID DOT APPEND LPAREN expression RPAREN .)
    EQUALV          reduce using rule 39 (factor -> ID DOT APPEND LPAREN expression RPAREN .)
    LT              reduce using rule 39 (factor -> ID DOT APPEND LPAREN expression RPAREN .)
    GT              reduce using rule 39 (factor -> ID DOT APPEND LPAREN expression RPAREN .)
    LTE             reduce using rule 39 (factor -> ID DOT APPEND LPAREN expression RPAREN .)
    GTE             reduce using rule 39 (factor -> ID DOT APPEND LPAREN expression RPAREN .)
    PLUS            reduce using rule 39 (factor -> ID DOT APPEND LPAREN expression RPAREN .)
    MINUS           reduce using rule 39 (factor -> ID DOT APPEND LPAREN expression RPAREN .)
    ID              reduce using rule 39 (factor -> ID DOT APPEND LPAREN expression RPAREN .)
    INPUT           reduce using rule 39 (factor -> ID DOT APPEND LPAREN expression RPAREN .)
    PRINT           reduce using rule 39 (factor -> ID DOT APPEND LPAREN expression RPAREN .)
    IF              reduce using rule 39 (factor -> ID DOT APPEND LPAREN expression RPAREN .)
    WHILE           reduce using rule 39 (factor -> ID DOT APPEND LPAREN expression RPAREN .)
    FOR             reduce using rule 39 (factor -> ID DOT APPEND LPAREN expression RPAREN .)
    SEMICOLON       reduce using rule 39 (factor -> ID DOT APPEND LPAREN expression RPAREN .)
    $end            reduce using rule 39 (factor -> ID DOT APPEND LPAREN expression RPAREN .)
    RBRACE          reduce using rule 39 (factor -> ID DOT APPEND LPAREN expression RPAREN .)
    RPAREN          reduce using rule 39 (factor -> ID DOT APPEND LPAREN expression RPAREN .)
    COMMA           reduce using rule 39 (factor -> ID DOT APPEND LPAREN expression RPAREN .)
    RBRACKET        reduce using rule 39 (factor -> ID DOT APPEND LPAREN expression RPAREN .)
    LBRACE          reduce using rule 39 (factor -> ID DOT APPEND LPAREN expression RPAREN .)


state 118

    (23) statement -> FOR ID EQUALS NUMBER SEMICOLON condition SEMICOLON . ID PLUSPLUS LBRACE statement RBRACE

    ID              shift and go to state 123


state 119

    (24) statement -> FOR ID IN ID LBRACE statement RBRACE .

    ID              reduce using rule 24 (statement -> FOR ID IN ID LBRACE statement RBRACE .)
    INPUT           reduce using rule 24 (statement -> FOR ID IN ID LBRACE statement RBRACE .)
    PRINT           reduce using rule 24 (statement -> FOR ID IN ID LBRACE statement RBRACE .)
    IF              reduce using rule 24 (statement -> FOR ID IN ID LBRACE statement RBRACE .)
    WHILE           reduce using rule 24 (statement -> FOR ID IN ID LBRACE statement RBRACE .)
    FOR             reduce using rule 24 (statement -> FOR ID IN ID LBRACE statement RBRACE .)
    SEMICOLON       reduce using rule 24 (statement -> FOR ID IN ID LBRACE statement RBRACE .)
    $end            reduce using rule 24 (statement -> FOR ID IN ID LBRACE statement RBRACE .)
    RBRACE          reduce using rule 24 (statement -> FOR ID IN ID LBRACE statement RBRACE .)


state 120

    (19) statement -> PRINT LPAREN expression COMMA STRING COMMA expression RPAREN .

    ID              reduce using rule 19 (statement -> PRINT LPAREN expression COMMA STRING COMMA expression RPAREN .)
    INPUT           reduce using rule 19 (statement -> PRINT LPAREN expression COMMA STRING COMMA expression RPAREN .)
    PRINT           reduce using rule 19 (statement -> PRINT LPAREN expression COMMA STRING COMMA expression RPAREN .)
    IF              reduce using rule 19 (statement -> PRINT LPAREN expression COMMA STRING COMMA expression RPAREN .)
    WHILE           reduce using rule 19 (statement -> PRINT LPAREN expression COMMA STRING COMMA expression RPAREN .)
    FOR             reduce using rule 19 (statement -> PRINT LPAREN expression COMMA STRING COMMA expression RPAREN .)
    SEMICOLON       reduce using rule 19 (statement -> PRINT LPAREN expression COMMA STRING COMMA expression RPAREN .)
    $end            reduce using rule 19 (statement -> PRINT LPAREN expression COMMA STRING COMMA expression RPAREN .)
    RBRACE          reduce using rule 19 (statement -> PRINT LPAREN expression COMMA STRING COMMA expression RPAREN .)


state 121

    (26) statementIF -> ELSE LBRACE statement . RBRACE

    RBRACE          shift and go to state 124


state 122

    (27) statementIF -> ELSE IF condition . LBRACE statement RBRACE

    LBRACE          shift and go to state 125


state 123

    (23) statement -> FOR ID EQUALS NUMBER SEMICOLON condition SEMICOLON ID . PLUSPLUS LBRACE statement RBRACE

    PLUSPLUS        shift and go to state 126


state 124

    (26) statementIF -> ELSE LBRACE statement RBRACE .

    ID              reduce using rule 26 (statementIF -> ELSE LBRACE statement RBRACE .)
    INPUT           reduce using rule 26 (statementIF -> ELSE LBRACE statement RBRACE .)
    PRINT           reduce using rule 26 (statementIF -> ELSE LBRACE statement RBRACE .)
    IF              reduce using rule 26 (statementIF -> ELSE LBRACE statement RBRACE .)
    WHILE           reduce using rule 26 (statementIF -> ELSE LBRACE statement RBRACE .)
    FOR             reduce using rule 26 (statementIF -> ELSE LBRACE statement RBRACE .)
    SEMICOLON       reduce using rule 26 (statementIF -> ELSE LBRACE statement RBRACE .)
    $end            reduce using rule 26 (statementIF -> ELSE LBRACE statement RBRACE .)
    RBRACE          reduce using rule 26 (statementIF -> ELSE LBRACE statement RBRACE .)


state 125

    (27) statementIF -> ELSE IF condition LBRACE . statement RBRACE
    (6) statement -> . ID EQUALS LBRACKET elements RBRACKET
    (7) statement -> . ID EQUALS LBRACKET RBRACKET
    (15) statement -> . INPUT LPAREN STRING RPAREN
    (16) statement -> . ID EQUALS INPUT LPAREN STRING RPAREN
    (17) statement -> . PRINT LPAREN STRING RPAREN
    (18) statement -> . PRINT LPAREN expression RPAREN
    (19) statement -> . PRINT LPAREN expression COMMA STRING COMMA expression RPAREN
    (20) statement -> . ID EQUALS expression
    (21) statement -> . IF condition LBRACE statement RBRACE statementIF
    (22) statement -> . WHILE condition LBRACE statement RBRACE
    (23) statement -> . FOR ID EQUALS NUMBER SEMICOLON condition SEMICOLON ID PLUSPLUS LBRACE statement RBRACE
    (24) statement -> . FOR ID IN ID LBRACE statement RBRACE
    (25) statement -> . empty
    (54) empty -> .

    ID              shift and go to state 12
    INPUT           shift and go to state 13
    PRINT           shift and go to state 14
    IF              shift and go to state 15
    WHILE           shift and go to state 16
    FOR             shift and go to state 17
    RBRACE          reduce using rule 54 (empty -> .)

    statement                      shift and go to state 127
    empty                          shift and go to state 18

state 126

    (23) statement -> FOR ID EQUALS NUMBER SEMICOLON condition SEMICOLON ID PLUSPLUS . LBRACE statement RBRACE

    LBRACE          shift and go to state 128


state 127

    (27) statementIF -> ELSE IF condition LBRACE statement . RBRACE

    RBRACE          shift and go to state 129


state 128

    (23) statement -> FOR ID EQUALS NUMBER SEMICOLON condition SEMICOLON ID PLUSPLUS LBRACE . statement RBRACE
    (6) statement -> . ID EQUALS LBRACKET elements RBRACKET
    (7) statement -> . ID EQUALS LBRACKET RBRACKET
    (15) statement -> . INPUT LPAREN STRING RPAREN
    (16) statement -> . ID EQUALS INPUT LPAREN STRING RPAREN
    (17) statement -> . PRINT LPAREN STRING RPAREN
    (18) statement -> . PRINT LPAREN expression RPAREN
    (19) statement -> . PRINT LPAREN expression COMMA STRING COMMA expression RPAREN
    (20) statement -> . ID EQUALS expression
    (21) statement -> . IF condition LBRACE statement RBRACE statementIF
    (22) statement -> . WHILE condition LBRACE statement RBRACE
    (23) statement -> . FOR ID EQUALS NUMBER SEMICOLON condition SEMICOLON ID PLUSPLUS LBRACE statement RBRACE
    (24) statement -> . FOR ID IN ID LBRACE statement RBRACE
    (25) statement -> . empty
    (54) empty -> .

    ID              shift and go to state 12
    INPUT           shift and go to state 13
    PRINT           shift and go to state 14
    IF              shift and go to state 15
    WHILE           shift and go to state 16
    FOR             shift and go to state 17
    RBRACE          reduce using rule 54 (empty -> .)

    statement                      shift and go to state 130
    empty                          shift and go to state 18

state 129

    (27) statementIF -> ELSE IF condition LBRACE statement RBRACE .

    ID              reduce using rule 27 (statementIF -> ELSE IF condition LBRACE statement RBRACE .)
    INPUT           reduce using rule 27 (statementIF -> ELSE IF condition LBRACE statement RBRACE .)
    PRINT           reduce using rule 27 (statementIF -> ELSE IF condition LBRACE statement RBRACE .)
    IF              reduce using rule 27 (statementIF -> ELSE IF condition LBRACE statement RBRACE .)
    WHILE           reduce using rule 27 (statementIF -> ELSE IF condition LBRACE statement RBRACE .)
    FOR             reduce using rule 27 (statementIF -> ELSE IF condition LBRACE statement RBRACE .)
    SEMICOLON       reduce using rule 27 (statementIF -> ELSE IF condition LBRACE statement RBRACE .)
    $end            reduce using rule 27 (statementIF -> ELSE IF condition LBRACE statement RBRACE .)
    RBRACE          reduce using rule 27 (statementIF -> ELSE IF condition LBRACE statement RBRACE .)


state 130

    (23) statement -> FOR ID EQUALS NUMBER SEMICOLON condition SEMICOLON ID PLUSPLUS LBRACE statement . RBRACE

    RBRACE          shift and go to state 131


state 131

    (23) statement -> FOR ID EQUALS NUMBER SEMICOLON condition SEMICOLON ID PLUSPLUS LBRACE statement RBRACE .

    ID              reduce using rule 23 (statement -> FOR ID EQUALS NUMBER SEMICOLON condition SEMICOLON ID PLUSPLUS LBRACE statement RBRACE .)
    INPUT           reduce using rule 23 (statement -> FOR ID EQUALS NUMBER SEMICOLON condition SEMICOLON ID PLUSPLUS LBRACE statement RBRACE .)
    PRINT           reduce using rule 23 (statement -> FOR ID EQUALS NUMBER SEMICOLON condition SEMICOLON ID PLUSPLUS LBRACE statement RBRACE .)
    IF              reduce using rule 23 (statement -> FOR ID EQUALS NUMBER SEMICOLON condition SEMICOLON ID PLUSPLUS LBRACE statement RBRACE .)
    WHILE           reduce using rule 23 (statement -> FOR ID EQUALS NUMBER SEMICOLON condition SEMICOLON ID PLUSPLUS LBRACE statement RBRACE .)
    FOR             reduce using rule 23 (statement -> FOR ID EQUALS NUMBER SEMICOLON condition SEMICOLON ID PLUSPLUS LBRACE statement RBRACE .)
    SEMICOLON       reduce using rule 23 (statement -> FOR ID EQUALS NUMBER SEMICOLON condition SEMICOLON ID PLUSPLUS LBRACE statement RBRACE .)
    $end            reduce using rule 23 (statement -> FOR ID EQUALS NUMBER SEMICOLON condition SEMICOLON ID PLUSPLUS LBRACE statement RBRACE .)
    RBRACE          reduce using rule 23 (statement -> FOR ID EQUALS NUMBER SEMICOLON condition SEMICOLON ID PLUSPLUS LBRACE statement RBRACE .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for VAR in state 0 resolved as shift
WARNING: shift/reduce conflict for ID in state 6 resolved as shift
WARNING: shift/reduce conflict for INPUT in state 6 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 6 resolved as shift
WARNING: shift/reduce conflict for IF in state 6 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 6 resolved as shift
WARNING: shift/reduce conflict for FOR in state 6 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 53 resolved as shift
